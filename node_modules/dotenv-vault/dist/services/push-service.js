"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PushService = void 0;
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const axios_1 = tslib_1.__importDefault(require("axios"));
const vars_1 = require("../vars");
const fs_1 = require("fs");
const core_1 = require("@oclif/core");
const append_to_ignore_service_1 = require("../services/append-to-ignore-service");
const log_service_1 = require("../services/log-service");
const abort_service_1 = require("../services/abort-service");
const login_service_1 = require("../services/login-service");
class PushService {
    constructor(attrs = {}) {
        this.cmd = attrs.cmd;
        this.environment = attrs.environment;
        this.filename = attrs.filename;
        this.dotenvMe = attrs.dotenvMe;
        this.yes = attrs.yes;
        this.log = new log_service_1.LogService({ cmd: attrs.cmd });
        this.abort = new abort_service_1.AbortService({ cmd: attrs.cmd });
        this.login = new login_service_1.LoginService({ cmd: attrs.cmd, dotenvMe: null, yes: this.yes });
    }
    async run() {
        new append_to_ignore_service_1.AppendToIgnoreService().run();
        if (vars_1.vars.missingEnvVault) {
            this.abort.missingEnvVault();
        }
        if (vars_1.vars.emptyEnvVault) {
            this.abort.emptyEnvVault();
        }
        if (vars_1.vars.missingEnvMe(this.dotenvMe)) {
            await this.login.login(false);
        }
        if (vars_1.vars.emptyEnvMe(this.dotenvMe)) {
            await this.login.login(false);
        }
        if (vars_1.vars.missingEnv(this.smartFilename)) {
            this.abort.missingEnv(this.smartFilename);
        }
        if (vars_1.vars.emptyEnv(this.smartFilename)) {
            this.abort.emptyEnv(this.smartFilename);
        }
        let pushingMsg = `Securely pushing (${this.smartFilename})`;
        if (this.smartEnvironment) {
            pushingMsg = `Securely pushing ${this.smartEnvironment} (${this.smartFilename})`;
        }
        core_1.CliUx.ux.action.start(`${chalk_1.default.dim(this.log.pretextRemote)}${pushingMsg}`);
        await this.push();
    }
    async push() {
        const options = {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            data: {
                environment: this.smartEnvironment,
                projectUid: vars_1.vars.vaultValue,
                meUid: this.meUid,
                dotenv: this.envContent,
            },
            url: this.url,
        };
        try {
            const resp = await (0, axios_1.default)(options);
            const environment = resp.data.data.environment;
            const envName = resp.data.data.envName;
            const newVaultData = resp.data.data.dotenvVault;
            const outputFilename = this.displayFilename(envName);
            core_1.CliUx.ux.action.stop();
            this.log.remote(`Securely pushed ${environment} (${outputFilename})`);
            // write .env.vault file
            if (newVaultData) {
                (0, fs_1.writeFileSync)('.env.vault', newVaultData);
                this.log.remote('Securely built vault (.env.vault)');
            }
            this.log.plain('');
            this.log.plain(`Run ${chalk_1.default.bold(`${vars_1.vars.cli} open`)} to view in the ui`);
        }
        catch (error) {
            core_1.CliUx.ux.action.stop('aborting');
            let errorMessage = null;
            let errorCode = 'PUSH_ERROR';
            let suggestions = [];
            errorMessage = error;
            if (error.response) {
                errorMessage = error.response.data;
                if (error.response.data && error.response.data.errors && error.response.data.errors[0]) {
                    const error1 = error.response.data.errors[0];
                    errorMessage = error1.message;
                    if (error1.code) {
                        errorCode = error1.code;
                    }
                    if (error1.suggestions) {
                        suggestions = error1.suggestions;
                    }
                }
            }
            this.abort.error(errorMessage, { code: errorCode, ref: '', suggestions: suggestions });
        }
    }
    get url() {
        return vars_1.vars.apiUrl + '/push';
    }
    get envContent() {
        return (0, fs_1.readFileSync)(this.smartFilename, 'utf8');
    }
    get smartEnvironment() {
        // 1. if user has set an environment for input then use that
        if (this.environment) {
            return this.environment;
        }
        return null; // otherwise, do not pass environment. dotenv-vault's api will smartly choose the main environment for the project (in most cases development)
    }
    get smartFilename() {
        // if user has set a filename for input then use that
        if (this.filename) {
            return this.filename;
        }
        if (this.smartEnvironment) {
            // in case of development being passed and .env.development file does not exist, then return .env. this covers use cases of custom environments like local (main), development, and production
            if (this.smartEnvironment === 'development' && !(0, fs_1.existsSync)('.env.development')) {
                return '.env';
            }
            return `.env.${this.smartEnvironment}`;
        }
        return '.env';
    }
    get meUid() {
        return this.dotenvMe || vars_1.vars.meValue;
    }
    displayFilename(envName) {
        // if user has set a filename for output then use that else use envName
        if (this.filename) {
            return this.filename;
        }
        return envName;
    }
}
exports.PushService = PushService;
